<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Motivation - Spex</title>
  <link rel="stylesheet" href="style.css?modified=2024-11-20">
  <link rel="shortcut icon" type="image/png" href="asset/spex.png">
  <script data-goatcounter="https://spex-lang.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<header class=box>
  <nav id="navbar" class="menu">
    <a href="index.html"><img class="logo" src="asset/spex.png" alt="Spex glasses">Spex</a>
    <a href="documentation.html">Documentation</a>
    <a href="community.html">Community</a>
  </nav>
  <div class="push">
    <a href="https://github.com/spex-lang/spex">Code</a>
  </div>
</header>
<noscript>
  <img src="https://spex-lang.goatcounter.com/count?t=Motivation+-+Spex"
       alt="goatcounter">
</noscript>
<main>
<h1 id="motivation">Motivation</h1>
<p><em>Work in progress</em></p>
<h2 id="what-is-a-specification-language">What is a "specification
language"?</h2>
<p>In a lecture, back in 2010, Joe Armstrong <a
href="https://youtu.be/ieEaaofM7uU?list=PL_aCdZH3eJJVki0YqHbJtqZKSmcbXH0jP&amp;t=68">said</a>:</p>
<blockquote>
<p>"We need languages to describe encodings and protocols not machine
instructions"</p>
</blockquote>
<p>He then went on to elaborate saying that we have plenty (too many)
programming languages (e.g. C, Java, Go, Python, Erlang, etc) which at a
high-level allow us to manipulate machines via machine instructions (and
syscalls). However we only have a few <em>specification languages</em>
which describe encodings and protocols, i.e. describe what's going on
<em>between</em> two, or more, machines!</p>
<p>In a later <a href="https://youtu.be/ed7A7r6DBsM?t=723">talk</a>
(2013) Joe has the following slide:</p>
<p><img src="asset/joe_protocols.png"
alt="Joe Armstrong&#39;s talk &quot;The How and Why of Fitting Things Together&quot;" /></p>
<p>Where the black boxes are written using programming languages while
the big red arrow between is what Joe means with encodings and
protocols. It's this big red arrow which is what we need different
languages for, and to distinguish them from "normal" programming
languages, we shall call them specification languages.</p>
<p><em>Spex</em> tries to be such a specification language.</p>
<h2 id="the-difference-between-apis-encoding-and-protocols">The
difference between APIs, encoding and protocols</h2>
<p>Before we can start talking about the shortcomings of current
specification languages, it's helpful to first break down Joe's red
arrow. It actually has three components:</p>
<ol type="1">
<li>The interface of the blackbox (the API), i.e. what messages the
component accepts;</li>
<li>The encoding of the messages, i.e. what bytes (or bits) are sent
over the communication channel;</li>
<li>The protocol, i.e. what sequences of messages are allowed.</li>
</ol>
<p>Hopefully it's clear what encodings are (e.g. UTF-8 encoded JSON or
binary Protobuf messages), but it might be worth pondering the
difference between APIs and protocols.</p>
<p>In the latter of the above mentioned talks, Joe gives an example
where merely knowing the API isn't good enough. The example he gives is
the POSIX filesystem API:</p>
<ul>
<li><code>open</code>: takes a filepath and returns a file
descriptor;</li>
<li><code>write</code>: takes a file descriptor and string and returns
how many bytes it successfully wrote;</li>
<li><code>close</code>: takes a file descriptor and closes it, thus
freeing up resources.</li>
</ul>
<p>Nothing in the API says, for example, that we can't continue writing
to a file descriptor that has been closed! This is where protocols come
in, saying for example that we can only write to a file descritor that
is open, etc.</p>
<p>One last point to note is that APIs can be synchronous or
asynchronous, as in the client of the API gets a response back
immediately upon making the call or it (potentially) gets the response
sometime in the future.</p>
<h2 id="what-are-the-problems-with-past-approaches">What are the
problems with past approaches?</h2>
<p>Now that we've established the differences between APIs, encodings
and protocols, we can start talking about where the current
specification languages fall short.</p>
<h3 id="choose-two-out-of-three">Choose two out of three</h3>
<p>The first thing to note is that very few specification languages
support specifying all three aspects. For example:</p>
<ul>
<li>OpenAPI specifications: describe synchronous APIs, the encoding can
affected by the content-type, e.g. <code>application/json</code>,
<code>application/xml</code> or
<code>application/x-www-form-urlencoded</code>, but there's no way to
specify protocols;</li>
<li>Protobuf: only specifies message encodings. Together with gRPC it
can be used to specify APIs also, but it cannot be used to specify
protocols;</li>
<li>JSON schema: can be used to disallow JSON messages that don't
conform to some schema, but again say something about which sequences of
messages are allowed.</li>
</ul>
<p>On the other side of the fence, we have things like <a
href="https://en.wikipedia.org/wiki/Session_type">session types</a>
which support specifications of APIs and protocols, but don't talk about
encodings.</p>
<p>There's one exception which supports specifying all three aspects and
that's Joe's <a
href="https://erlang.org/workshop/2002/Armstrong.pdf">Universal Binary
Format</a> (2002), it seems to have been largely forgotten about
though.</p>
<h3 id="syntax-and-tooling">Syntax and tooling</h3>
<p>In addition to the aspets of what you can specify, it's also
important to consider how pleasant it's to read and write such
specifications and what you can do with them -- i.e. what tooling is
available once we have a specification.</p>
<p>Ultimately the low use of specification languages must at least
somewhat be a reflection of the fact that specifications are not worth
the effort?</p>
<ul>
<li>the risk of the specification and the real system drifting out of
sync (i.e. either the system or the specification is changed, but we
forget to update the other).
<ul>
<li>no a problem for protobuf grpc</li>
</ul></li>
</ul>
<p>OpenAPI specifications are written in JSON or YAML, which verbose and
hard to read. Microsoft's <a href="https://typespec.io/">TypeSpec</a>
(2024) introduces a sane syntax inspired by TypeScript.</p>
<ul>
<li><p>OpenAPI tooling is mostly third-party, no unified
human-to-machine interface?</p></li>
<li><p>(<a
href="https://www.asyncapi.com/en">https://www.asyncapi.com/en</a>)</p></li>
</ul>
<h2 id="what-the-spex-specification-language-tries-to-do-different">What
the Spex specification language tries to do different</h2>
<ul>
<li><p>Sane syntax</p></li>
<li><p>Good unified tooling that coevolves with the syntax, we can add
features that will be hard to replicate in OpenAPI, e.g.:</p>
<ul>
<li>Refinement types -- validation logic;</li>
<li>Model definitions -- fakes rather than mocks and better
fuzzing.</li>
</ul></li>
<li><p>Full system specifications</p>
<ul>
<li><p>async and sync apis</p></li>
<li><p>Machine-to-machine interfaces, might also want to specify
human-to-machine interfaces (e.g. CLI, GUIs?)</p></li>
<li><p>OpenAPI and Protobuf describe the interface of one machine, but
what about the topology? I.e. which machine talks to which
machine?</p></li>
<li><p>The long term vision for <em>Spex</em> is allow for complete
system specifications, rather than mere HTTP JSON API specifications.
HTTP API specifications of components in a system captures how the
components may be called, but they don't say how the components are
related to each other. For example, one obvious thing that's missing is
that there can be async message passing between the components. These
more complete system specifications open up the potential for other
kinds of tooling:</p>
<ul>
<li>Linters that ensures global consistancy;</li>
<li>More complete documentation with diagrams for visualising how
components are connected;</li>
<li>Generation of deployment related code;</li>
<li>Load testing.</li>
</ul></li>
</ul></li>
<li><p>Longer term / Lab / experimentation</p>
<ul>
<li>Separate types from their encodings?</li>
<li>Spex in Spex?</li>
<li>file system example: protocols specify valid (single threaded)
sequences, what about concurrently accessed protocols?</li>
</ul></li>
</ul>
<p>Spex tries to address this shortcoming of specifications by in
addition to being a specification language, it's also a verifier that
checks if some system respects the specification -- thereby always
ensuring that the two are in sync.</p>
<p>In the process of testing the real system against the specification
is will also produce minimal test cases for potential problems it
notices along the way:</p>
<ul>
<li>Non-2xx responses;</li>
<li>JSON response decoding and type issues;</li>
<li>Non-reachable APIs.</li>
</ul>
<p>(We'll look at examples of how exactly this gets reported in the next
section on features.)</p>
<p>In the future we'd like to derive more useful functionality from
specifications, including:</p>
<ul>
<li>Joe's contract checker;</li>
<li>Ability to import and export OpenAPI/Swagger, Protobuf, etc. Think
of how Pandoc can covert between text formats, perhaps we can do the
same between specifications;</li>
<li>Generate a prototype implementation from a specification, so that
you can demo your idea or hand of a working server HTTP API to the
frontend team before the actual backend is done (without risking that
there will be a mismatch in the end, since the real backend is tested
against the same specification as the prototype is derived from);</li>
<li>A REPL, which allows you to explore a system using a specification.
Tab completion is provided for the API and random payload data is
generated on the fly;</li>
<li>A time traveling debugger which enables you to step forwards and
backwards through a sequence of API calls, in order to explore how the
system evolves over time.</li>
<li>Lua templating (again similar to Pandoc) which enables code
generation from specifications or the minimal test cases that the
verifer produces;</li>
<li>The ability to refine types, e.g.
<code>{ petId : Int | petId &gt; 0 }</code> and be able to generate
validation logic from these;</li>
<li>Generate diagrams for a better overview of how components are
connected.</li>
</ul>
<p>With this future functionality we hope to get to the point where
there's a clear benefit to writing specifications!</p>
<h2 id="conclusion">Conclusion</h2>
<ul>
<li>What we mean by specification languages</li>
<li>How the current approaches are lacking</li>
<li>How we propose to fix the current problems and go beyond</li>
</ul>
</main>
</body>
</html>
